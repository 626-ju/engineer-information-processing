※공통※
  1) call by value, call by Ref 잘 생각하면서 풀기
  2) 출력할 때 실수 안하게 꼼꼼히 살펴보기
 


※C※

  >> &, |, ^, ~, 다시 보기

  >> 다양한 진법 전환 연습하기
     2, 8 ,16 

  >> 2의 보수 개념 및 음수 진법 전환 다시 보기


  >> 소수점 아래 2진법으로
     ex) 10.625  =>  0.625*2 = 1.25 (정수 부분 1)
                                 0.25*2 = 0.5 (정수 부분 0) 
                                          0.5*2 = 1.0(정수 부분 1)

      ==> 기존 정수 부분 (10 =1010(2)) 
              소수 부분 (0.625 = 0.101(2))
      10.625 => 1010.101(2)


  >> %-3.5f   
    - : (왼쪽부터 정렬)
    3 : 정수 => 최소필드 폭(너비)
    .5 : 소수 몇번째 자리까지

       f에 4.2 대입 시
       => 4.20000 (최소 너비 폭보다 더 길 떄

  >> %3d
     + : (오른쪽 정렬) 
     3 : 정수 => 최소필드 폭(너비)

        d에 42 대입 시
        =>    4 2
            _ _ _
      
  
  >> %s 주소값 받음. %c,%d 값을 받음

  >> *pt+++=10  // (*: 가리키는 곳의 값. *pt => pt가 가리키는 곳의 값)
      => *pt+=10;
         pt++; 와 같은 형태

  >> 기본적인 아스키 코드
     'A' : 65
     'a' : 97
     '0' : 48
     ex )  *p+2 같은 형태 => (p가 가리키는 곳의 값이 'A'일 때) +2를 하니 65+2 == 67. (%c로 출력시 'C')


  >> 구조체의 크기
     padding bit가 적용된다,
      ex)
          struct Student {
              char grade;          =>   구조체 내부에 가장큰 자료형의 크기를 따라감      1 : char   => 총 8byte
              int  age;                                                       4 : int
          }                          

           struct Teacher {                                                  1
              char grade;                                                    1
              char subject        =>                                         패딩  => 총 8 Byte 
              int  age;                                                      패딩 
            }                                                                4 


            struct Classroom{                                          50 : char[50]
              char name[50]       =>                                   패딩          => 총 56 Byte
              int personnel                                            패딩            
           }                                                           4  :int 







※JAVA※

  >> 접근제어자 알아두기 
     public : 자유롭게 접근
     protected : 상속 관계, 같은 패키지 내에서 접근
     default : 같은 패키지 내부에서
     private : 같은 클래스 내부에서 (정보은닉)

  >> String => 값 없으면 null로 초기화
     int => 0으로 초기화

  >> Sys.out.println(인스턴스 이름)
     ==> 자동으로 인스턴스.toString() 호출

  >> 생성없이 
    q = p // q는 p의 주소값을 가짐(동일한 인스턴스를 참조)

  >> 메서드 오버로딩은 반환 형태가 달라도 가능(매개변수 개수랑 타입 둘중 하나만이라도 다르게)
     메서드 오버라이딩은 반환형태까지 일치해야 함(매개변수 개수랑 타입도 물론)

 
  >> 🐶업캐스팅된 형태로 클래스 생성 + 메서드 오버라이딩 했을 때
      => 해당 메서드 호출하면 무조건 오버라이딩한(생성한 자식에 있는)메서드가 호출된다고 함. A <- B <- C 일떄   A a = new C();// C가 오버라이딩한 메서드 호출 
                                                                                           A a = new B();// B가 오버라이딩한 메서드 호출 
        
          ==> 가상메서드테이블(VMT)를 가지는데 오버라이딩한 순간 여기에 해당 메서드의 주소값이 변경되어서 오버라이딩 한걸로 호출된다고 함
              (업 캐스팅을 해도 VMT가 사라지지는 않아서)

      + 하이딩 : 오버라이딩 형태인데 오버라이딩 전 후 둘 다 static이 붙어 있음
                => 이럴 때는(부모클래스에 있는) 메서드를 호출한다.

       // 오버로딩 한 경우는 부모랑 자식 중 매개변수 타입 맞는 거 따라가고,
          없으면 그나마 가까운 거에 형변환되서 들어가는 것 같음(메서드에서만) 생성자 오버로딩일 경우 타입 안 맞으면 나가리
          (메서드에 인자로 값을 넣을 때 해당 타입에 맞게 프로모션이 일어날 수 있지만, 생성자에서는 컴파일 에러 뜨는 거 같네)

       // 멤버변수는 상위 쿨래스, 부모클래스의 형태를 따라감
         ex) A a = new B(); //A,B모드 num이란 변수를 가졌을 떄 => a.num => A에 존재하는 num

       // 메서드 오버라이딩한 곳에서 변수를 사용할 경우, 메서드가 오버라이딩 된 클래스의 변수 참조


  

  >> 정확한 계산을 위해 보통 소수를 넣으면 일반적으로 double 타입으로 받는듯?


  >> static 변수, 메서드 => 선언된 클래스 내에서 공통으로 사용, 생성 없이 .접근으로 사용 가능 
                            (static 메서드는 선언 시 바로 메모리에 올라가서 일반적인 멤버 변수 사용x) 


  >> throw => 예외 만들 때 // throws 예외를 넘길 때


  >> 추상메서드를 가지는 추상클래스는 abstract로 선언 
     => 생성불가(new x) => 상속 받은 후 자식클래스를 생성 가능   
       ✨ abstract 키워드가 붙었는데 메서드의 접근제어자를 private로 하면 오류 =>변수는 가능할까?=> 변수에 abstact를 쓸 일이 없잖아...
                                                                  -> 상속받아서 구현해야 하는데 접근을 못하니

  >> 인터페이스 interface 키워드로 선언(마찬가지로 직접 생성 불가)   
     ✨ 인터페이스는 그냥 변수, 메서드 둘 다 private 사용을 못하게 해둠(public만 가능) + 변수선언자체가 안된다고 하네(상수만 가능)
     => implements를 통해 존재하는 '모든' 추상메서드를 구현 후 사용 가능                                                                        
     ==> int age=4; 같이 되어 있느건 public static final생략된거래...ㄷㄷ
     ===> int age; 이런 형태 불가능



  >>  str1.compareTo(str2)  str1=Java ,str=java일 때 -32라는 값이 나옴(떨어져있는 거리 만큼)//같으면 0 반환



  >> 자료구조 스택 : 넣을 땐 top포인터 증가 후 값 넣기. 뺄 땐 값 빼고 top 포인터 감소 시키기


  >> 🧐🧐🧐🧐제네릭 오버로딩 이해가 잘 안가네...



※Python※


  >> 파이썬은 3/2 => 1.5로 나옴. (몫을 구하고 싶으면 3//2  => 1)  // 4/2 => 2.0 /자체가 그냥 실수형으로 넘기는듯

  >> C       ==>  1 : 0
     JAVA    ==> true : false
     Pythone ==> True : False
      (출력결과 표기할 때 조심)

  >> -5~256 사이의 작은 정수 값은 해당 값을 사용할 때 같은 주소 참조(JAVA에 스프링 풀 같은 건가?)

  >> else if 대신 elif사용

  >> {} 코드블럭이 없고 들여쓰기로 나눔

  >> 삼항조건식 형태가 다름
     참 조건 거짓 //형태


  >> while조건) else 같은 형태도 있음

  >> 빈문자열 표시는 " //(큰 따옴표 하나로 함)

  >>  print() //자동 개행 기능 있음 
      ==> print(a,b,c) => , 출력x 
      ===> print(a, end=") //개행하지말고 마지막에 "(빈문자열)붙이고 이어서 출력하란 뜻 

  >> '''텍스트''' 혹은  """텍스트"""  //개행 포함해서 출력

  >> "abc"*3 // abcabcabc
  
  >> str.title() // 단어 제일 앞문자 대문자로 (.capital~()는 문장 제일 앞에만)
     str.strip() // java .trim() 비슷 양끝 공백제거 //자바도 11버전 이후 strip() 생김 
      
  >> "a".join(]'a','b','c']) // aabac처럼 사이에 a넣고 합친 문자열 반환

  >>  f"abcdef{변수}" // f 포맷스트링을 가리킴. {}안에 변수에 문자열 값으로 치환해서 할당

  >> ⭐️⭐️⭐️⭐️⭐️문자열 및 리스트 슬라이싱
      1) string[i] :인덱스 i번째 문자 반환
      2) string[-i] : 뒤에서부터 -1로 시작했을 때 해당하는 문자 반환

      3) string[0:4] : 0부터 인덱스4 '이전'까지 문자열 반환
      4) string[-5:-2] :뒤에서부터 -5인덱스부터 시작해서 -2앞에까지 문자열반환 (문자열 뒤집기x)

      5) string[::2] : 0부터 끝까지 2개씩 건너가서 문자열 뽑아오기
      6) string[::-1] : 뒤에서부터 끝까지 거꾸로 한칸씩 건너뛰기 => .reverse()
          //3번째에 음수오면 거꾸로 출력한다 생각하면 된다.

      7) (주의) string[:3:-1] : 0부터가 아니라 -1부터 인덱스가 3인(-3말고,3본인 제외)까지 자르기 


      =>  🌈🌈범위 벗어나면 오류x 빈문자열 출력함.(리스트에선 빈 [ ])

  >> ⭐️⭐️⭐️⭐️ 자료구조 종류
      1) List : 배열하고 비슷해보이는데 c, java의 배열과 차이로는 데이터 상관 없이 담을 수 있음 // [  ]
      2) Dictionary : key-value 쌍. 키 중복x 키에 문자열만 가능=>js object랑 비슷한 느낌(itertator아님) // { }
          print(딕셔너리이름.keys()); //이런 형태로 출력시 
          => dict_keys(["키이름1","키이름2"]) 형태로 출력
      3) Tuple : 순서o, 변형불가능(imutable), *중복가능(set과 가장 다른 점) // ( )
              () 사용하는데 (6)은 그냥 숫자 (6,)이런 형태가 튜플
      4) Set : 집합. 순서x, 중복x // { } 딕셔너리처럼 {} 쓰지만 키-밸류형태 x
             .remove(삭제할 요소명) =>없으면 오류
             .discard(삭제할 요소명) => 없어도 오류x

  >> _del_ 키워드 함수 : 종료 시 호출=> 생명주기랑 관련있는건가?

  >> 파이썬은 상속 받을 때 클래시 선언시 매개변수로 부모 클래스 받음( extends같은 키워드 안씀)
     => +++(특이사항) 생성자 (_init_)에 부모 클래스 생성자 언급x ? => 부모 생성자 안 거침 

  >> 함수 내에서 전역변수에 접근하려면 global 키워드 사용해서 선언해야 함. 아니면 다 지역변수

  >> 함수의 return 값으면 b,c 같은 형태면 튜플로 반환함 
      => return b,c // (b,c)


  >> 🌟🌟함수의 매개변수에 기본값 설정 했을 떄 리스트 타입이면 실행 종료되도 값 남김
     ex) def appendList(x,y=[])
              y.append(x)
              print(y)         
         appendList(3)   //출력 : [3]
         appendList(4)   //출력 : [3,4] //그런데 매개변수로 값을 넘겨줬을 떄
         appendList(5,[10,20])  //출력 : [10,20,5]
         appendList(6)      //출력 : [3,4,6] //매개변수로 넘긴 값은 없애고 그 전에 값이 남아있음

      기본형은 그런거 없이 그냥 함수 실행 종료 시 값 날려버림

  
  >> 람다 함수 작성해야할 수도 있으니 형태 기억하기

  >> max(country,key=lambda x : x[2])   
     =>  country 배열의 요소의 인덱스 2번을 기준으로 최대값구하기(여러 개면 제일 처음 꺼)

  >> tuple = [(1,2),(1,1),(5,7),(7,5)]
      sorted(tuple) // 결과 : [(1,1),(1,2),(5,7),(7,5)]
                              //처음 꺼 비교, 같으면 다음 꺼 비교
      
      위에 max예시처럼 람다함수로 특정 키를 기준으로 하면 그것만 비교해서 정렬
      ex) sorted(tuple, key=lambda a: a[1]) => [(1,1),(1,2),(7,5),(5,7)]

    

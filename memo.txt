※C※

  >> 다양한 진법 전환 연습하기
     2, 8 ,16 

  >> 2의 보수 개념 및 음수 진법 전환 다시 보기


  >> 소수점 아래 2진법으로
     ex) 10.625  =>  0.625*2 = 1.25 (정수 부분 1)
                                 0.25*2 = 0.5 (정수 부분 0) 
                                          0.5*2 = 1.0(정수 부분 1)

      ==> 기존 정수 부분 (10 =1010(2)) 
              소수 부분 (0.625 = 0.101(2))
      10.625 => 1010.101(2)


  >> %-3.5f   
    - : (왼쪽부터 정렬)
    3 : 정수 => 최소필드 폭(너비)
    .5 : 소수 몇번째 자리까지

       f에 4.2 대입 시
       => 4.20000 (최소 너비 폭보다 더 길 떄

  >> %3d
     + : (오른쪽 정렬) 
     3 : 정수 => 최소필드 폭(너비)

        d에 42 대입 시
        =>    4 2
            _ _ _
      
  
  >> %s 주소값 받음. %c,%d 값을 받음

  >> *pt+++=10  // (*: 가리키는 곳의 값. *pt => pt가 가리키는 곳의 값)
      => *pt+=10;
         pt++; 와 같은 형태

  >> 기본적인 아스키 코드
     'A' : 65
     'a' : 97
     '0' : 48
     ex )  *p+2 같은 형태 => (p가 가리키는 곳의 값이 'A'일 때) +2를 하니 65+2 == 67. (%c로 출력시 'C')


  >> 구조체의 크기
     padding bit가 적용된다,
      ex)
          struct Student {
              char grade;          =>   구조체 내부에 가장큰 자료형의 크기를 따라감      1 : char   => 총 8byte
              int  age;                                                       4 : int
          }                          

           struct Teacher {                                                  1
              char grade;                                                    1
              char subject        =>                                         패딩  => 총 8 Byte 
              int  age;                                                      패딩 
            }                                                                4 


            struct Classroom{                                          50 : char[50]
              char name[50]       =>                                   패딩          => 총 56 Byte
              int personnel                                            패딩            
           }                                                           4  :int 





※JAVA※

  >> 접근제어자 알아두기 
     public : 자유롭게 접근
     protected : 상속 관계, 같은 패키지 내에서 접근
     default : 같은 패키지 내부에서
     private : 같은 클래스 내부에서 (정보은닉)

  >> String => 값 없으면 null로 초기화
     int => 0으로 초기화

  >> Sys.out.println(인스턴스 이름)
     ==> 자동으로 인스턴스.toString() 호출

  >> 생성없이 
    q = p // q는 p의 주소값을 가짐(동일한 인스턴스를 참조)

  >> 메서드 오버로딩은 반환 형태가 달라도 가능(매개변수 개수랑 타입 둘중 하나만이라도 다르게)
     메서드 오버라이딩은 반환형태까지 일치해야 함(매개변수 개수랑 타입도 물론)

 
  >> 🐶업캐스팅된 형태로 클래스 생성 + 메서드 오버라이딩 했을 때
      => 해당 메서드 호출하면 무조건 오버라이딩한(생성한 자식에 있는)메서드가 호출된다고 함. A <- B <- C 일떄   A a = new C();// C가 오버라이딩한 메서드 호출 
                                                                                           A a = new B();// B가 오버라이딩한 메서드 호출 
        
          ==> 가상메서드테이블(VMT)를 가지는데 오버라이딩한 순간 여기에 해당 메서드의 주소값이 변경되어서 오버라이딩 한걸로 호출된다고 함
              (업 캐스팅을 해도 VMT가 사라지지는 않아서)

      + 하이딩 : 오버라이딩 형태인데 오버라이딩 전 후 둘 다 static이 붙어 있음
                => 이럴 때는(부모클래스에 있는) 메서드를 호출한다.

       // 오버로딩 한 경우는 부모랑 자식 중 매개변수 타입 맞는 거 따라가고,
          없으면 그나마 가까운 거에 형변환되서 들어가는 것 같음(메서드에서만) 생성자 오버로딩일 경우 타입 안 맞으면 나가리
          (메서드에 인자로 값을 넣을 때 해당 타입에 맞게 프로모션이 일어날 수 있지만, 생성자에서는 컴파일 에러 뜨는 거 같네)

       // 멤버변수는 상위 쿨래스, 부모클래스의 형태를 따라감
         ex) A a = new B(); //A,B모드 num이란 변수를 가졌을 떄 => a.num => A에 존재하는 num

       // 메서드 오버라이딩한 곳에서 변수를 사용할 경우, 메서드가 오버라이딩 된 클래스의 변수 참조


  

  >> 정확한 계산을 위해 보통 소수를 넣으면 일반적으로 double 타입으로 받는듯?


  >> static 변수, 메서드 => 선언된 클래스 내에서 공통으로 사용, 생성 없이 .접근으로 사용 가능 
                            (static 메서드는 선언 시 바로 메모리에 올라가서 일반적인 멤버 변수 사용x) 




※Python※
